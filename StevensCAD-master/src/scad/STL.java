/*
 * @link StevensCADLicense.html
 */
package scad;

import java.io.*;
import java.nio.*;
import java.nio.file.*;
import java.nio.channels.*;
import java.util.*;
import primitives.Cube;
import primitives.Cylinder;
import primitives.Shape;
import primitives.Shape3d;
/**
 *
 * @author dkruger
 */
public final class STL {
    public static void writeSTL(Polyhedron s, String filename) {
        FileWriter f = null;
        final int blockSize = 1024; // do 1k triangles at a time
        try {
            f = new FileWriter(filename);   
            StringBuilder b = new StringBuilder(65536);
            ArrayList<Triangle> triangles = s.triangles();
            final int numBlocks = triangles.size() / blockSize;
            for (int i = 0; i < numBlocks; ++i) {
                for (int j = i*blockSize; j < i*blockSize + blockSize; ++j)
                    writeTextSTL(triangles.get(j),b);
                f.write(b.toString());
                b.setLength(0);
            }
            for (int i = triangles.size() / blockSize * blockSize;
                        i < triangles.size(); ++i) {
                writeTextSTL(triangles.get(i), b);
            }
            f.write(b.toString());
            f.close();
        } catch(Exception e) {
            e.printStackTrace();
        }
    }
    
    private static void writeHeader(DataOutputStream d, String msg, int maxLen) throws IOException {
        if (msg.length() > maxLen)
            msg = msg.substring(0, maxLen);
        d.writeBytes(msg);
        byte b = 0;
        while (d.size() < maxLen)
            d.writeByte(b);
    }
    public static void writeBinarySTL(Shape s, String filename) {
        DataOutputStream d = null;
        try {
            d = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(filename)));
            writeHeader(d, "Binary STL: Generated by Stevens CAD", 80);
            d.writeInt(Integer.reverseBytes(s.triangles().size()));
            ArrayList<Triangle> triangles = s.triangles();
            for (Triangle t : triangles) {
                writeBinarySTL(t, d);
            }
        } catch(Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (d != null)
                    d.close();
            } catch(IOException e2) {
                e2.printStackTrace();
            }
        }
    }

    /**
     * Binary Indexed Format is a more efficient binary format than STL designed to write vertices once 
     * and maintain the information about shared vertices
     * 
     * The format is similar to binary STL.  All values are little-endian
     * 
     * 80 byte header
     * 4 byte integer defining how many shapes are contained
     * for each shape, two integers:
     * 4 byte integer defining number of vertices
     * 4 byte integer defining number of facets
     * list of all vertices as floats x y z
     * list of all triangles as indices into the floats for this shape, where first one is offset 0
     * 
     * @param p
     * @param filename 
     */
    public static void writeBIF(ArrayList<Shape> shapes, String filename) {
        DataOutputStream d = null;
        try {
            d = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(filename)));
            writeHeader(d, "BIF: Generated by Stevens CAD", 80);
            d.writeInt(Integer.reverseBytes(shapes.size()));
            for (Shape s : shapes) {
                d.writeInt(Integer.reverseBytes(s.getVertices().size())); // write number of vertices for this shape, little-endian
                d.writeInt(Integer.reverseBytes(s.triangles().size())); // write number of triangles for this shape, little-endian
                HashMap<Vector, Integer> vectorPos = new HashMap<>(shapes.size());
                int index = 0;
                for (Vector v : s.getVertices()) {
                    writeBinary(v, d);
                    vectorPos.put(v, index++);
                }
                for (Triangle t : s.triangles()) {
                    writeBinary(t, vectorPos, d);
                }
            }
        } catch(Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (d != null)
                    d.close();
            } catch(IOException e2) {
                e2.printStackTrace();
            }
        }
    }
    private static void writeBinary(Vector v, DataOutputStream d) throws IOException {
        d.writeInt(Integer.reverseBytes(Float.floatToIntBits((float)v.x)));
        d.writeInt(Integer.reverseBytes(Float.floatToIntBits((float)v.y)));
        d.writeInt(Integer.reverseBytes(Float.floatToIntBits((float)v.z)));
    }

    private static void writeBinary(Triangle t, HashMap<Vector, Integer> vectorPos, DataOutputStream d) throws IOException {
        d.writeInt(Integer.reverseBytes(vectorPos.get(t.get(0))));
        d.writeInt(Integer.reverseBytes(vectorPos.get(t.get(1))));
        d.writeInt(Integer.reverseBytes(vectorPos.get(t.get(2))));
    }
    
    

    public static void writeBinarySTL1(Shape p, DataOutputStream dos) throws IOException {
            byte b = 0;
            while (dos.size() < 80)
                dos.writeByte(b);
            dos.writeInt(p.size()); // number of points.  Go back and re-write this later.
            int count = 0;
            ArrayList<Triangle> triangles = p.triangles();
            for (Triangle t : triangles) {
                writeBinarySTL(t, dos);
                ++count;
            }
    }
    public static void writeSTL1(Shape p, FileWriter f) throws IOException {
       
        final int blockSize = 1024; // do 1k triangles at a time
        
        StringBuilder b = new StringBuilder(65536);
        ArrayList<Triangle> triangles = p.triangles();
        final int numBlocks = triangles.size() / blockSize;
        
        //write solid
        b.append("solid\n");
        for (int i = 0; i < numBlocks; ++i) {
            for (int j = i*blockSize; j < i*blockSize + blockSize; ++j)
                writeTextSTL(triangles.get(j),b);
            f.write(b.toString());
            b.setLength(0);
        }
        for (int i = triangles.size() / blockSize * blockSize;
                    i < triangles.size(); ++i) {
            writeTextSTL(triangles.get(i), b);
        }
        //Write endsolid
        b.append("endsolid");
        f.write(b.toString());
            
    }
    public static Polyhedron readSTL1(FileReader f) throws IOException {
        Scanner sc = new Scanner(f);
        Polyhedron p = new Polyhedron();
        while(sc.hasNext()) {
            String s = sc.nextLine();
            if(s.startsWith("facet normal")) {
                Facet facet = readTextSTL(sc);
                p.add(facet);
            }
            
        }
        return p;
    }
        /**
     * Returns this triangle face in STL string format.
     *
     * @param sb string builder
     *
     * @return the specified string builder
     */
    
    public static StringBuilder writeTextSTL(Triangle t, StringBuilder sb) {
        sb.append("facet normal ").append(t.normal()).append("\nouter loop\n");
        sb.append("vertex ").append(t.get(0)).append('\n');
        sb.append("vertex ").append(t.get(1)).append('\n');
        sb.append("vertex ").append(t.get(2)).append('\n');
        sb.append("endloop\nendfacet\n");
        return sb;
    }
    public static Facet readTextSTL(Scanner sc) throws IOException {
        Facet f = new Facet();
        int i = 0;
        while(sc.hasNext()) {
            String s = sc.nextLine();
            if(s.startsWith("vertex")) {
                String[] arr = s.split(",*\\s+");
                double x = Double.valueOf(arr[1]);
                double y = Double.valueOf(arr[2]);
                double z = Double.valueOf(arr[3]);
                f.add(new Vector(x, y, z));
                System.out.println(x + "    " + y + "    " + z );
            }
            if(s.startsWith("endloop")) break;
        }
        System.out.println("facet:  " + f);
        return f;
    } 
        /**
     * Write a triangle into a byte buffer in STL binary format.
     *
     * @return the specified string builder
     */
    public static void writeBinarySTL(Triangle t, DataOutputStream d) throws IOException {
        d.writeInt(Integer.reverseBytes(Float.floatToIntBits((float)t.normal().x)));
        d.writeInt(Integer.reverseBytes(Float.floatToIntBits((float)t.normal().y)));
        d.writeInt(Integer.reverseBytes(Float.floatToIntBits((float)t.normal().z)));
        d.writeInt(Integer.reverseBytes(Float.floatToIntBits((float)t.get(0).x)));
        d.writeInt(Integer.reverseBytes(Float.floatToIntBits((float)t.get(0).y)));
        d.writeInt(Integer.reverseBytes(Float.floatToIntBits((float)t.get(0).z)));
        d.writeInt(Integer.reverseBytes(Float.floatToIntBits((float)t.get(1).x)));
        d.writeInt(Integer.reverseBytes(Float.floatToIntBits((float)t.get(1).y)));
        d.writeInt(Integer.reverseBytes(Float.floatToIntBits((float)t.get(1).z)));
        d.writeInt(Integer.reverseBytes(Float.floatToIntBits((float)t.get(2).x)));
        d.writeInt(Integer.reverseBytes(Float.floatToIntBits((float)t.get(2).y)));
        d.writeInt(Integer.reverseBytes(Float.floatToIntBits((float)t.get(2).z)));
        d.writeShort(0);
    }
    public static void writeBinarySTL2(Polyhedron p, String filename) {
        java.nio.file.Path filePath = Paths.get(filename);

        // Open a channel in write mode on your file.
        try (WritableByteChannel channel = Files.newByteChannel(filePath, StandardOpenOption.CREATE,StandardOpenOption.WRITE)) {
            // Allocate a new buffer.
            ByteBuffer buf = ByteBuffer.allocateDirect(64*1024);
//            ByteBuffer buf = ByteBuffer.allocate(64 * 1024);
            ArrayList<Triangle> triangles = p.triangles();
            // Write your triangle data to the buffer.
            for (int i = 0; i < triangles.size(); i += 1024) {
                for (int j = i; j < i + 1024; ++j)
                    writeBinarySTL(triangles.get(j), buf);
                    buf.flip(); // stop modifying buffer so it can be written to disk
                    channel.write(buf);  // Write your buffer's data.
                    buf.flip();
            }
            channel.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public static void writeBinarySTL(Triangle t, ByteBuffer buf) {
        buf.putInt(Integer.reverseBytes(Float.floatToIntBits((float)t.normal().x)));
        buf.putInt(Integer.reverseBytes(Float.floatToIntBits((float)t.normal().y)));
        buf.putInt(Integer.reverseBytes(Float.floatToIntBits((float)t.normal().y)));
        buf.putInt(Integer.reverseBytes(Float.floatToIntBits((float)t.get(0).x)));
        buf.putInt(Integer.reverseBytes(Float.floatToIntBits((float)t.get(0).y)));
        buf.putInt(Integer.reverseBytes(Float.floatToIntBits((float)t.get(0).z)));
        buf.putInt(Integer.reverseBytes(Float.floatToIntBits((float)t.get(1).x)));
        buf.putInt(Integer.reverseBytes(Float.floatToIntBits((float)t.get(1).y)));
        buf.putInt(Integer.reverseBytes(Float.floatToIntBits((float)t.get(1).z)));
        buf.putInt(Integer.reverseBytes(Float.floatToIntBits((float)t.get(2).x)));
        buf.putInt(Integer.reverseBytes(Float.floatToIntBits((float)t.get(2).y)));
        buf.putInt(Integer.reverseBytes(Float.floatToIntBits((float)t.get(2).z)));
        buf.putShort((short)0);
    }
    
    private static void parseAscii(File f) throws IOException, FileNotFoundException {
        BufferedReader in = new BufferedReader(new FileReader(f));
        ArrayList<Vector> vertices = new ArrayList<>();
        String line;
        while ((line = in.readLine()) != null) {
            String[] num = line.trim().split("\\s+");
            if (num[0].equals("vertex")) {
                Vector v = new Vector(Float.parseFloat(num[0]),
                                          Float.parseFloat(num[1]),
                                          Float.parseFloat(num[2]));
                vertices.add(v);
            } else if (num[0].equals("facet") && num[1].equals("normal")) {
 //               normal = new Vector3d(Float.parseFloat(num[2]), Float.parseFloat(num[3]), Float.parseFloat(num[4]));
            }
        }
        in.close();
    }

    private static void parseAsciiSTL(File f) throws IOException, FileNotFoundException {
        int numTriangles = (int)(f.length() / 200);
        BufferedReader in = new BufferedReader(new FileReader(f));
        ArrayList<Vector> vertices = new ArrayList<>(numTriangles);
        ArrayList<Triangle> triangles = new ArrayList<>(numTriangles);
        String line;
        while ((line = in.readLine()) != null) {
            String[] num = line.trim().split("\\s+");
            if (num[0].equals("vertex")) {
                Vector v = new Vector(Float.parseFloat(num[0]),
                                          Float.parseFloat(num[1]),
                                          Float.parseFloat(num[2]));
                vertices.add(v);
            } else if (num[0].equals("facet") && num[1].equals("normal")) {
 //               normal = new Vector3d(Float.parseFloat(num[2]), Float.parseFloat(num[3]), Float.parseFloat(num[4]));
            }
        }
        in.close();
    }

    public static void parseBinary(File f) throws IOException {
        DataInputStream dis = new DataInputStream(
            new BufferedInputStream(new FileInputStream(f)));
        byte header[] = new byte[80];
        dis.read(header);
        int numTriangles = Integer.reverseBytes(dis.readInt()); //TODO: byte order?
        ArrayList<Vector> vertices = new ArrayList<Vector>(numTriangles);
        ArrayList<Triangle> triangles = new ArrayList<Triangle>(numTriangles);
        for (int t = 0; t < numTriangles; t++) {
            Vector p1 =
                    new Vector(Float.intBitsToFloat(Integer.reverseBytes(dis.readInt())),
                            Float.intBitsToFloat(Integer.reverseBytes(dis.readInt())),
                            Float.intBitsToFloat(Integer.reverseBytes(dis.readInt()))
                    );
            Vector p2 =
                    new Vector(Float.intBitsToFloat(Integer.reverseBytes(dis.readInt())),
                            Float.intBitsToFloat(Integer.reverseBytes(dis.readInt())),
                            Float.intBitsToFloat(Integer.reverseBytes(dis.readInt()))
                    );
            Vector p3 =
                    new Vector(Float.intBitsToFloat(Integer.reverseBytes(dis.readInt())),
                            Float.intBitsToFloat(Integer.reverseBytes(dis.readInt())),
                            Float.intBitsToFloat(Integer.reverseBytes(dis.readInt()))
                    );
            Vector normal =
                    new Vector(Float.intBitsToFloat(Integer.reverseBytes(dis.readInt())),
                            Float.intBitsToFloat(Integer.reverseBytes(dis.readInt())),
                            Float.intBitsToFloat(Integer.reverseBytes(dis.readInt()))
                    );
            short unused = dis.readShort(); //TODO: can be color in some implementations...
            vertices.add(p1);
            vertices.add(p2);
            vertices.add(p3);
            triangles.add(new Triangle(p1,p2,p3));
        }
        dis.close();
    }
    public static void main(String[] arg) {
        writeBinarySTL(new Cube(30).poly, "cube.stl");
        //writeSTL(new Cylinder(40, 10 , 10).poly, "cube.stl");
    }
}